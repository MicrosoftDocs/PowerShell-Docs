---
keywords: powershell,cmdlet
locale: en-us
ms.date: 11/8/2019
online version: 
schema: 2.0.0
title: about_Thread_Jobs
---
# About Jobs

## SHORT DESCRIPTION

Provides information about PowerShell thread based jobs.
Thread jobs are a type of PowerShell job that run a command or expression in a
separate thread within the current session process, without interacting with
the current session.

## LONG DESCRIPTION

This topic explains how to run thread jobs in PowerShell on a local computer.
For information about running background jobs on a local computer,
see [about_Jobs](about_Jobs.md).

You can start a thread job in one of two ways.

The first way is with the `Start-ThreadJob` cmdlet. This cmdlet is available in
the **ThreadJob** module that ships with PowerShell. `Start-ThreadJob` returns a
single job object that encapsulates the running command or script, and can be
used with all PowerShell job manipulating cmdlets.

The second way is with the `ForEach-Object` cmdlet, with the `-Parallel`
parameter script block argument along with the `-AsJob` parameter switch.
This cmdlet returns a single (parent) job object that contains a child job for
each input piped to the cmdlet. Each child job runs script in a separate thread
with a (`-ThrottleLimit`) limit to how many child jobs run at a given time.

## THE JOB CMDLETS

|Cmdlet           |Description                                            |
|-----------------|-------------------------------------------------------|
|`Start-ThreadJob`|Starts a thread job on a local computer.               |
|`ForEach-Object` |Starts thread jobs for each piped input object, when   |
|                 |used with -Parallel and -AsJob parameters.             |
|`Get-Job`        |Gets the jobs that were started in the current session.|
|`Receive-Job`    |Gets the results of jobs.                              |
|`Stop-Job`       |Stops a running job.                                   |
|`Wait-Job`       |Suppresses the command prompt until one or all jobs are|
|                 |complete.                                              |
|`Remove-Job`     |Deletes a job.                                         |

## HOW TO START A THREAD JOB ON THE LOCAL COMPUTER

To start a thread job on the local computer, use either the `Start-ThreadJob`
or `ForEach-Object` cmdlets.

To write a `Start-ThreadJob` command, enclose the command or script the job
runs in curly braces (`{ }`).

The following command starts a thread job that runs a `Get-Process` command on
the local computer.

```powershell
Start-ThreadJob -ScriptBlock { Get-Process }
```

The `Start-ThreadJob` command returns a `ThreadJob` object that represents the
running job. The job object contains useful information about the job including
its current running status. It collects the results of the job as the results
are being generated.

To write a `ForEach-Object -Parallel` command, pipe data to the command and
enclose the command or script the job runs in curly braces(`{ }`). Use the
`-AsJob` parameter switch so that a job object is returned.

The following command starts a job that contains child jobs for each input
value piped to the command. Each child job runs the `Write-Output` command with
a piped input value as the argument.

```powershell
1..5 | ForEach-Object -Parallel { Write-Output $_ } -AsJob
```

The `ForEach-Object -Parallel` command returns a `PSTaskJob` object that
contains child jobs for each piped input value. The job object contains useful
information about the child jobs running status. It collects the results of the
child jobs as the results are being generated.

## HOW TO WAIT FOR A JOB TO COMPLETE AND RETRIEVE JOB RESULTS

You can use PowerShell job cmdlets, such as `Wait-Job` and
`Receive-Job` to wait for a job to complete and then return all results
generated by the job.

The following command starts a thread job that runs a `Get-Process` command,
then waits for the command to complete, and finally returns all data results
generated by the command.

```powershell
Start-ThreadJob -ScriptBlock { Get-Process } | Wait-Job | Receive-Job
```

The following command starts a job that runs a `Write-Output` command for each
piped input, then waits for all child jobs to complete, and finally returns all
data results generated by the child jobs.

```powershell
1..5 | ForEach-Object -Parallel { Write-Output $_ } -AsJob | Wait-Job | Receive-Job
```

The `Receive-Job` cmdlet returns the results of the child jobs.

```powershell
1
3
2
4
5
```

Because each child job runs parallel, the order of the generated results is not
guaranteed.

## POWERSHELL CONCURRENCY AND JOBS

PowerShell concurrently runs commands and script through jobs. There are
three job based solutions provided by PowerShell to support concurrency.

|Job            |Description                                                  |
|---------------|-------------------------------------------------------------|
|`RemoteJob`    |Command and script run on a remote computer.                 |
|`BackgroundJob`|Command and script run in a separate process on the local    |
|               |machine.                                                     |
|`ThreadJob`    |Command and script run in a separate thread within the same  |
|               |process on the local machine.                                |

Each type of job has benefits and drawbacks. Running script remotely on a
separate machine or in a separate process has great isolation, and any errors
won't affect other running jobs or the client that started the job. But the
remoting layer adds a lot of overhead, including object serialization. All
objects passed to and from the remote session must be serialized and then
deserialized as it passes between the client and the target session. This can
take up a lot of compute and memory resources for complex objects such as a
`Process` object that is returned from the `Get-Process` cmdlet.

## POWERSHELL THREAD BASED JOBS

Thread based jobs are not as robust as Remote and Background jobs, because they
run in the same process on different threads. If one job has a critical error
that crashes the process, then all other jobs in the process will also fail.

On the other hand, thread based jobs have much less overhead. They don't need
to use the PowerShell remoting layer or serialization. The result is that
thread based jobs tend to run much faster and use far less resources than the
other job types.

## THREAD JOB PERFORMANCE

Even though thread based jobs are faster and lighter weight than other types of
jobs, they still have overhead which can become significant when compared to
work the job is doing. PowerShell runs commands and script in a session, where
only one command or script can be run at a time. In order to run multiple
commands and scripts at a time, multiple sessions must be created. And these
PowerShell sessions have overhead associated with them.

Therefore it is important to use thread jobs only when the work is significant
compared to the overhead of the job. If your script is doing trivial work then
it is probably better to run in a single script.

```powershell
(Measure-Command {
    1..1000 | ForEach-Object -Parallel { "Hello: $_" } -AsJob | Wait-Job
        | Receive-Job
}).TotalMilliseconds
10457.962


(Measure-Command {
    1..1000 | ForEach-Object { "Hello: $_" }
}).TotalMilliseconds
18.4473
```

The above example shows a trivial script where a foreach loop writes a string
message 1000 times. In the first case, it is run as a `ForEach -Parallel` job
that internally runs 1000 child jobs. Due to job overhead it takes over 10
seconds to complete.

The second example runs the `ForEach` cmdlet normally and each string
write is executed sequentially in a simple script block without any job
overhead. It completes in a mere 18 milliseconds.

```powershell
$logNames.count
10

Measure-Command {
    $logs = $logNames | ForEach-Object -Parallel {
        Get-WinEvent -LogName $_ -MaxEvents 5000 2>$null
    } -ThrottleLimit 10 -AsJob | Wait-Job | Receive-Job
}

TotalMilliseconds : 115994.3 (1 minute 56 seconds)
$logs.Count
50000
```

In the above example up to 5000 entries are collected for ten separate system
logs. Since this involves reading a number of logs, it makes sense to do the
operations in parallel. And the job completes over twice as fast as when the script is run sequentially.

```powershell
Measure-Command {
    $logs = $logNames | ForEach-Object {
        Get-WinEvent -LogName $_ -MaxEvents 5000 2>$null
    }
}

TotalMilliseconds : 252398.4321 (4 minutes 12 seconds)
$logs.Count
50000
```

## THREAD JOBS AND VARIABLES

Variables are passed into thread jobs in various ways.

`Start-ThreadJob` can accept variables that are piped to the cmdlet, passed in
to the script block via the `$using` keyword, or passed in via the
`-ArgumentList` parameter.

```powershell
$msg = "Hello"

$msg | Start-ThreadJob { $input | Write-Output } | Wait-Job | Receive-Job

Start-ThreadJob { Write-Output $using:msg } | Wait-Job | Receive-Job

Start-ThreadJob { param ([string] $message) Write-Output $message } -ArgumentList @($msg) | Wait-Job | Receive-Job
```

`ForEach-Object -Parallel` accepts piped in variables, and variables passed
directly to the script block via the `$using` keyword.

```powershell
$msg = "Hello"

$msg | ForEach-Object -Parallel { Write-Output $_ } -AsJob | Wait-Job | Receive-Job

1..1 | ForEach-Object -Parallel { Write-Output $using:msg } -AsJob | Wait-Job | Receive-Job
```

Since thread jobs run in the same process, any variable reference type passed
into the job has to be treated carefully. If it is not a thread safe object
then it should never be assigned to, and method and properties should never be
invoked on it.

```powershell
$threadSafeDictionary = [System.Collections.Concurrent.ConcurrentDictionary[string,object]]::new()
$job = Get-Process | ForEach-Object -Parallel {
    $dict = $using:threadSafeDictionary
    $dict.TryAdd($_.ProcessName, $_)
} -AsJob

$job | Wait-Job | Receive-Job

$threadSafeDictionary["pwsh"]

NPM(K) PM(M) WS(M) CPU(s) Id SI ProcessName
------ ----- ----- ------ -- -- -----------
112 108.25 124.43 69.75 16272 1 pwsh
```

The above example passes a thread safe dotNet `ConcurrentDictionary` object to
all child jobs to collect uniquely named process objects. Since it is a thread
safe object, it can be safely used while the child jobs run concurrently in the
process.
